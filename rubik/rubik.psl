vunit i_rubik(rubik(synthesis))
{

   signal f_num_colors : integer_vector(0 to 7);


   -- set all declarations to run on clk_i
   default clock is rising_edge(clk_i);


   -----------------------------
   -- ASSERTIONS ABOUT OUTPUTS
   -----------------------------

   f_edge_u2_f0 : assert always {u2 /= f0};
   f_edge_u2_l1 : assert always {u2 /= l1};
   f_edge_l1_f0 : assert always {l1 /= f0};

   f_edge_u3_f1 : assert always {u3 /= f1};
   f_edge_r0_f1 : assert always {r0 /= f1};
   f_edge_r0_u3 : assert always {r0 /= u3};

   f_edge_l3_f2 : assert always {l3 /= f2};
   f_edge_d0_f2 : assert always {d0 /= f2};
   f_edge_l3_d0 : assert always {l3 /= d0};

   f_edge_d1_f3 : assert always {d1 /= f3};
   f_edge_r2_f3 : assert always {r2 /= f3};
   f_edge_d1_r2 : assert always {d1 /= r2};

   f_edge_u0_l0 : assert always {u0 /= l0};
   f_edge_b1_l0 : assert always {b1 /= l0};
   f_edge_u0_b1 : assert always {u0 /= b1};

   f_edge_l2_d2 : assert always {l2 /= d2};
   f_edge_d2_b3 : assert always {d2 /= b3};
   f_edge_b3_l2 : assert always {b3 /= l2};

   f_edge_d3_r3 : assert always {d3 /= r3};
   f_edge_r3_b2 : assert always {r3 /= b2};
   f_edge_d3_b2 : assert always {d3 /= b2};

   f_edge_r1_u1 : assert always {r1 /= u1};
   f_edge_r1_b0 : assert always {r1 /= b0};
   f_edge_u1_b0 : assert always {u1 /= b0};

   process (all)
      variable num_colors : integer_vector(0 to 7);
   begin
      num_colors := (others => 0);
      num_colors(to_integer(unsigned(u0))) := num_colors(to_integer(unsigned(u0))) + 1;
      num_colors(to_integer(unsigned(u1))) := num_colors(to_integer(unsigned(u1))) + 1;
      num_colors(to_integer(unsigned(u2))) := num_colors(to_integer(unsigned(u2))) + 1;
      num_colors(to_integer(unsigned(u3))) := num_colors(to_integer(unsigned(u3))) + 1;
      num_colors(to_integer(unsigned(f0))) := num_colors(to_integer(unsigned(f0))) + 1;
      num_colors(to_integer(unsigned(f1))) := num_colors(to_integer(unsigned(f1))) + 1;
      num_colors(to_integer(unsigned(f2))) := num_colors(to_integer(unsigned(f2))) + 1;
      num_colors(to_integer(unsigned(f3))) := num_colors(to_integer(unsigned(f3))) + 1;
      num_colors(to_integer(unsigned(r0))) := num_colors(to_integer(unsigned(r0))) + 1;
      num_colors(to_integer(unsigned(r1))) := num_colors(to_integer(unsigned(r1))) + 1;
      num_colors(to_integer(unsigned(r2))) := num_colors(to_integer(unsigned(r2))) + 1;
      num_colors(to_integer(unsigned(r3))) := num_colors(to_integer(unsigned(r3))) + 1;
      num_colors(to_integer(unsigned(d0))) := num_colors(to_integer(unsigned(d0))) + 1;
      num_colors(to_integer(unsigned(d1))) := num_colors(to_integer(unsigned(d1))) + 1;
      num_colors(to_integer(unsigned(d2))) := num_colors(to_integer(unsigned(d2))) + 1;
      num_colors(to_integer(unsigned(d3))) := num_colors(to_integer(unsigned(d3))) + 1;
      num_colors(to_integer(unsigned(b0))) := num_colors(to_integer(unsigned(b0))) + 1;
      num_colors(to_integer(unsigned(b1))) := num_colors(to_integer(unsigned(b1))) + 1;
      num_colors(to_integer(unsigned(b2))) := num_colors(to_integer(unsigned(b2))) + 1;
      num_colors(to_integer(unsigned(b3))) := num_colors(to_integer(unsigned(b3))) + 1;
      num_colors(to_integer(unsigned(l0))) := num_colors(to_integer(unsigned(l0))) + 1;
      num_colors(to_integer(unsigned(l1))) := num_colors(to_integer(unsigned(l1))) + 1;
      num_colors(to_integer(unsigned(l2))) := num_colors(to_integer(unsigned(l2))) + 1;
      num_colors(to_integer(unsigned(l3))) := num_colors(to_integer(unsigned(l3))) + 1;
      f_num_colors <= num_colors;
   end process;

   f_colors : assert always {f_num_colors(0 to 5) = (0 to 5 => 4)};


   -----------------------------
   -- ASSUMPTIONS ABOUT INPUTS
   -----------------------------

   -- We prevent any reset at all, because that would be cheating :-)
   f_no_rst : assume always {not rst_i};


   --------------------------------------------
   -- COVER STATEMENTS TO VERIFY REACHABILITY
   --------------------------------------------

   -- Attempt to solve the cube from the given initial condition.
   f_done : cover {done_o};

} -- vunit i_rubik(rubik(synthesis))

